# 内存模型
## 1. 为什么要学内存模型？
Go 是 并发语言，核心在 goroutine + channel + 内存共享。

内存模型告诉我们：当多个 goroutine 同时访问/修改数据时，什么是安全的，什么是不确定的。

不懂内存模型，很容易写出“偶尔错、难复现”的并发 Bug。

## 2. 基础概念

在 Go 内存模型中，核心有三点：

1. 顺序一致性（Sequential Consistency）
    - 单个 goroutine 内，代码执行结果与书写顺序一致。
    - 多个 goroutine 之间，除非通过 同步原语（channel、sync 包、原子操作），否则无法保证内存可见性。

2. happens-before 关系（关键！）
    - 表示两个操作的执行先后顺序的约束。
    - 若 A happens-before B，则 A 的结果对 B 可见。
    - 常见 happens-before 关系：
        - 一个 goroutine 的操作 → 下一个操作
        - channel 的 send → 对应的 receive
        - sync.Mutex.Unlock → 随后的 sync.Mutex.Lock
        - sync.Once.Do 的函数体只执行一次

3. 数据竞争（Data Race）
    - 两个 goroutine 并发访问同一变量，且至少有一个写入，没有同步手段保护 → 未定义行为。

## 3. 实践
- `go run -race main.go`：可以使用-race来检测是否有竞态。

- goroutine 可能还没执行完，主函数就退出了。
    - 用 sync.WaitGroup 等待。
    - sync.WaitGroup的作用是保证在所有Add都Done之后再退出

- send happens-before receive
    - A send on a channel happens before the corresponding receive from that channel completes.
    - 向 channel 的发送操作发生在相应接收操作完成之前。

### 如何解决竞态的方法
1. 使用`sync.atomic`进行原子操作：`atomic.AddInt32(&counter, 1)`
2. 使用`sync.Mutex`互斥锁：`mutex.Lock() / mutex.Unlock()`
3. 使用`sync.Once`：验证内存可见性保证
4. 使用`sync.RWMutex`读写锁：`mu.RLock() / mu.RUnlock() / mu.Lock() / mu.Unlock()`
5. 使用`channel`同步：原理"send happens-before receive", 保证了内存可见性顺序。

### 实战练习：
1. 实现一个 goroutine 池
2. 实现一个安全的缓存（带读写锁）
3. 用 atomic 实现无锁计数器


### ✅ 总结：
1. 记住一个黄金法则：不要依赖 CPU/编译器执行顺序，只依赖 happens-before 保证的数据可见性。
2. 工具：channel、sync.Mutex、sync.Once、atomic 就是 Go 内存模型的“四件套”。